<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/sample/src/main/kotlin/com/mocharealm/accompanist/sample/ui/utils/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sample/src/main/kotlin/com/mocharealm/accompanist/sample/ui/utils/Color.kt" />
              <option name="originalContent" value="package com.mocharealm.accompanist.sample.ui.utils&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.core.graphics.ColorUtils&#10;&#10;fun Color.copyHsl(&#10;    hue: Float? = null,&#10;    saturation: Float? = null,&#10;    lightness: Float? = null,&#10;    alpha: Float? = null&#10;): Color {&#10;    // 1. 创建一个Float数组来存储HSL值&#10;    val hsl = FloatArray(3)&#10;&#10;    // 2. 将Compose Color (ARGB) 转换为 HSL&#10;    // toArgb() 将Compose Color转为Android的Int颜色值&#10;    ColorUtils.colorToHSL(this.toArgb(), hsl)&#10;&#10;    // 3. 使用用户提供的新值，如果用户未提供（为null），则保留原始值&#10;    // ?: 是 Elvis 操作符，如果左侧为null，则使用右侧的值&#10;    val newHue = hue ?: hsl[0]&#10;    val newSaturation = saturation ?: hsl[1]&#10;    val newLightness = lightness ?: hsl[2]&#10;    val newAlpha = alpha ?: this.alpha&#10;&#10;    // 4. 将最终的HSL值转换回 ARGB Int 颜色值&#10;    val finalColorInt = ColorUtils.HSLToColor(floatArrayOf(newHue, newSaturation, newLightness))&#10;&#10;    // 5. 从Int颜色值创建Compose Color，并应用最终的透明度&#10;    return Color(finalColorInt).copy(alpha = newAlpha)&#10;}" />
              <option name="updatedContent" value="package com.mocharealm.accompanist.sample.ui.utils&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.core.graphics.ColorUtils&#10;&#10;fun Color.copyHsl(&#10;    hue: Float? = null,&#10;    saturation: Float? = null,&#10;    lightness: Float? = null,&#10;    alpha: Float? = null&#10;): Color {&#10;    // 1. Create a Float array to store HSL values&#10;    val hsl = FloatArray(3)&#10;&#10;    // 2. Convert Compose Color (ARGB) to HSL&#10;    // toArgb() converts Compose Color to Android's Int color value&#10;    ColorUtils.colorToHSL(this.toArgb(), hsl)&#10;&#10;    // 3. Use user-provided new values, if user didn't provide (null), keep original values&#10;    // ?: is Elvis operator, if left side is null, use right side value&#10;    val newHue = hue ?: hsl[0]&#10;    val newSaturation = saturation ?: hsl[1]&#10;    val newLightness = lightness ?: hsl[2]&#10;    val newAlpha = alpha ?: this.alpha&#10;&#10;    // 4. Convert final HSL values back to ARGB Int color value&#10;    val finalColorInt = ColorUtils.HSLToColor(floatArrayOf(newHue, newSaturation, newLightness))&#10;&#10;    // 5. Create Compose Color from Int color value and apply final alpha&#10;    return Color(finalColorInt).copy(alpha = newAlpha)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sample/src/main/kotlin/com/mocharealm/accompanist/sample/ui/utils/modifier/ClickFeedbackModifier.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sample/src/main/kotlin/com/mocharealm/accompanist/sample/ui/utils/modifier/ClickFeedbackModifier.kt" />
              <option name="originalContent" value="package com.mocharealm.accompanist.sample.ui.utils.modifier&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.AnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.GraphicsLayerScope&#10;import androidx.compose.ui.hapticfeedback.HapticFeedback&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.input.pointer.PointerEvent&#10;import androidx.compose.ui.input.pointer.PointerEventPass&#10;import androidx.compose.ui.input.pointer.PointerEventType&#10;import androidx.compose.ui.layout.Measurable&#10;import androidx.compose.ui.layout.MeasureResult&#10;import androidx.compose.ui.layout.MeasureScope&#10;import androidx.compose.ui.node.CompositionLocalConsumerModifierNode&#10;import androidx.compose.ui.node.DelegatingNode&#10;import androidx.compose.ui.node.LayoutModifierNode&#10;import androidx.compose.ui.node.ModifierNodeElement&#10;import androidx.compose.ui.node.PointerInputModifierNode&#10;import androidx.compose.ui.node.currentValueOf&#10;import androidx.compose.ui.platform.InspectorInfo&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.unit.Constraints&#10;import androidx.compose.ui.unit.IntSize&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.collections.firstOrNull&#10;import kotlin.let&#10;import kotlin.ranges.coerceIn&#10;&#10;class ClickFeedbackNode(&#10;    var pressScale: Float,&#10;    var hoverScale: Float,&#10;    var pressAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var releaseAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var hoverAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var maxHoverOffset: Float,&#10;    var onPress: () -&gt; Unit,&#10;    var onClick: () -&gt; Unit&#10;) : DelegatingNode(), CompositionLocalConsumerModifierNode, LayoutModifierNode,&#10;    PointerInputModifierNode {&#10;&#10;    private val animatedScale = Animatable(1f)&#10;    private val animatedOffsetX = Animatable(0f)&#10;    private val animatedOffsetY = Animatable(0f)&#10;    private var isPressed = false&#10;    private var pressJob: Job? = null&#10;    private var hasTriggeredLongPress = false&#10;    private var isHovered = false&#10;    private var haptics: HapticFeedback? = null&#10;&#10;    private val layerBlock: GraphicsLayerScope.() -&gt; Unit = {&#10;        scaleX = animatedScale.value&#10;        scaleY = animatedScale.value&#10;        translationX = animatedOffsetX.value&#10;        translationY = animatedOffsetY.value&#10;    }&#10;&#10;    override fun onPointerEvent(&#10;        pointerEvent: PointerEvent,&#10;        pass: PointerEventPass,&#10;        bounds: IntSize&#10;    ) {&#10;        if (pass == PointerEventPass.Main) {&#10;            when (pointerEvent.type) {&#10;                PointerEventType.Press -&gt; {&#10;                    isPressed = true&#10;                    hasTriggeredLongPress = false&#10;                    coroutineScope.launch {&#10;                        animatedScale.animateTo(pressScale, pressAnimationSpec)&#10;                    }&#10;                    pressJob = coroutineScope.launch {&#10;                        delay(500)&#10;                        if (isPressed) {&#10;                            hasTriggeredLongPress = true&#10;                            haptics?.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                            onPress()&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Release -&gt; {&#10;                    if (isPressed) {&#10;                        isPressed = false&#10;                        pressJob?.cancel()&#10;                        pressJob = null&#10;&#10;                        coroutineScope.launch {&#10;                            val targetScale = if (isHovered) hoverScale else 1f&#10;                            animatedScale.animateTo(targetScale, releaseAnimationSpec)&#10;                        }&#10;                        if (!hasTriggeredLongPress) {&#10;                            onClick()&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Enter -&gt; {&#10;                    isHovered = true&#10;                    if (!isPressed) {&#10;                        coroutineScope.launch {&#10;                            animatedScale.animateTo(hoverScale, hoverAnimationSpec)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Exit -&gt; {&#10;                    isHovered = false&#10;                    if (!isPressed) {&#10;                        coroutineScope.launch {&#10;                            launch { animatedScale.animateTo(1f, hoverAnimationSpec) }&#10;                            launch { animatedOffsetX.animateTo(0f, hoverAnimationSpec) }&#10;                            launch { animatedOffsetY.animateTo(0f, hoverAnimationSpec) }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Move -&gt; {&#10;                    if (isHovered &amp;&amp; !isPressed) {&#10;                        val position = pointerEvent.changes.firstOrNull()?.position&#10;                        position?.let { pos -&gt;&#10;                            val centerX = bounds.width / 2f&#10;                            val centerY = bounds.height / 2f&#10;&#10;                            // 计算相对于中心的偏移量&#10;                            val offsetX = (pos.x - centerX) / centerX&#10;                            val offsetY = (pos.y - centerY) / centerY&#10;&#10;                            // 限制偏移量范围并应用最大偏移&#10;                            val clampedOffsetX = offsetX.coerceIn(-1f, 1f) * maxHoverOffset&#10;                            val clampedOffsetY = offsetY.coerceIn(-1f, 1f) * maxHoverOffset&#10;&#10;                            // 直接设置值而不是动画，实现即时跟随&#10;                            coroutineScope.launch {&#10;                                animatedOffsetX.snapTo(clampedOffsetX)&#10;                                animatedOffsetY.snapTo(clampedOffsetY)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCancelPointerInput() {&#10;        isPressed = false&#10;        coroutineScope.launch {&#10;            val targetScale = if (isHovered) hoverScale else 1f&#10;            launch { animatedScale.animateTo(targetScale, releaseAnimationSpec) }&#10;            launch { animatedOffsetX.animateTo(0f, releaseAnimationSpec) }&#10;            launch { animatedOffsetY.animateTo(0f, releaseAnimationSpec) }&#10;        }&#10;    }&#10;&#10;    override fun MeasureScope.measure(&#10;        measurable: Measurable,&#10;        constraints: Constraints&#10;    ): MeasureResult {&#10;        val placeable = measurable.measure(constraints)&#10;        haptics = currentValueOf(LocalHapticFeedback)&#10;        return layout(placeable.width, placeable.height) {&#10;            placeable.placeWithLayer(0, 0, layerBlock = layerBlock)&#10;        }&#10;    }&#10;}&#10;&#10;private data class ClickFeedbackElement(&#10;    val pressScale: Float,&#10;    val hoverScale: Float,&#10;    val pressAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val releaseAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val hoverAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val maxHoverOffset: Float = 8f,&#10;    val onPress: () -&gt; Unit,&#10;    val onClick: () -&gt; Unit&#10;) : ModifierNodeElement&lt;ClickFeedbackNode&gt;() {&#10;    override fun InspectorInfo.inspectableProperties() {&#10;        name = &quot;ClickFeedback&quot;&#10;        properties[&quot;pressScale&quot;] = pressScale&#10;        properties[&quot;hoverScale&quot;] = hoverScale&#10;        properties[&quot;pressAnimationSpec&quot;] = pressAnimationSpec&#10;        properties[&quot;releaseAnimationSpec&quot;] = releaseAnimationSpec&#10;        properties[&quot;hoverAnimationSpec&quot;] = hoverAnimationSpec&#10;        properties[&quot;maxHoverOffset&quot;] = maxHoverOffset&#10;        properties[&quot;onPress&quot;] = onPress&#10;        properties[&quot;onClick&quot;] = onClick&#10;    }&#10;&#10;&#10;    override fun create(): ClickFeedbackNode {&#10;        return ClickFeedbackNode(&#10;            pressScale, hoverScale, pressAnimationSpec, releaseAnimationSpec,&#10;            hoverAnimationSpec, maxHoverOffset,&#10;            onPress, onClick&#10;        )&#10;    }&#10;&#10;    override fun update(node: ClickFeedbackNode) {&#10;        node.pressScale = pressScale&#10;        node.hoverScale = hoverScale&#10;        node.pressAnimationSpec = pressAnimationSpec&#10;        node.releaseAnimationSpec = releaseAnimationSpec&#10;        node.hoverAnimationSpec = hoverAnimationSpec&#10;        node.maxHoverOffset = maxHoverOffset&#10;        node.onPress = onPress&#10;        node.onClick = onClick&#10;    }&#10;}&#10;&#10;fun Modifier.clickFeedback(&#10;    pressScale: Float = 0.95f,&#10;    hoverScale: Float = 1.05f,&#10;    pressAnimationSpec: AnimationSpec&lt;Float&gt; = tween(100),&#10;    releaseAnimationSpec: AnimationSpec&lt;Float&gt; = tween(400),&#10;    hoverAnimationSpec: AnimationSpec&lt;Float&gt; = tween(400),&#10;    maxHoverOffset: Float = 8f,&#10;    onPress: () -&gt; Unit = {},&#10;    onClick: () -&gt; Unit&#10;): Modifier = this then ClickFeedbackElement(&#10;    pressScale, hoverScale, pressAnimationSpec, releaseAnimationSpec,&#10;    hoverAnimationSpec, maxHoverOffset,&#10;    onPress, onClick&#10;)" />
              <option name="updatedContent" value="package com.mocharealm.accompanist.sample.ui.utils.modifier&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.AnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.GraphicsLayerScope&#10;import androidx.compose.ui.hapticfeedback.HapticFeedback&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.input.pointer.PointerEvent&#10;import androidx.compose.ui.input.pointer.PointerEventPass&#10;import androidx.compose.ui.input.pointer.PointerEventType&#10;import androidx.compose.ui.layout.Measurable&#10;import androidx.compose.ui.layout.MeasureResult&#10;import androidx.compose.ui.layout.MeasureScope&#10;import androidx.compose.ui.node.CompositionLocalConsumerModifierNode&#10;import androidx.compose.ui.node.DelegatingNode&#10;import androidx.compose.ui.node.LayoutModifierNode&#10;import androidx.compose.ui.node.ModifierNodeElement&#10;import androidx.compose.ui.node.PointerInputModifierNode&#10;import androidx.compose.ui.node.currentValueOf&#10;import androidx.compose.ui.platform.InspectorInfo&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.unit.Constraints&#10;import androidx.compose.ui.unit.IntSize&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.collections.firstOrNull&#10;import kotlin.let&#10;import kotlin.ranges.coerceIn&#10;&#10;class ClickFeedbackNode(&#10;    var pressScale: Float,&#10;    var hoverScale: Float,&#10;    var pressAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var releaseAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var hoverAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    var maxHoverOffset: Float,&#10;    var onPress: () -&gt; Unit,&#10;    var onClick: () -&gt; Unit&#10;) : DelegatingNode(), CompositionLocalConsumerModifierNode, LayoutModifierNode,&#10;    PointerInputModifierNode {&#10;&#10;    private val animatedScale = Animatable(1f)&#10;    private val animatedOffsetX = Animatable(0f)&#10;    private val animatedOffsetY = Animatable(0f)&#10;    private var isPressed = false&#10;    private var pressJob: Job? = null&#10;    private var hasTriggeredLongPress = false&#10;    private var isHovered = false&#10;    private var haptics: HapticFeedback? = null&#10;&#10;    private val layerBlock: GraphicsLayerScope.() -&gt; Unit = {&#10;        scaleX = animatedScale.value&#10;        scaleY = animatedScale.value&#10;        translationX = animatedOffsetX.value&#10;        translationY = animatedOffsetY.value&#10;    }&#10;&#10;    override fun onPointerEvent(&#10;        pointerEvent: PointerEvent,&#10;        pass: PointerEventPass,&#10;        bounds: IntSize&#10;    ) {&#10;        if (pass == PointerEventPass.Main) {&#10;            when (pointerEvent.type) {&#10;                PointerEventType.Press -&gt; {&#10;                    isPressed = true&#10;                    hasTriggeredLongPress = false&#10;                    coroutineScope.launch {&#10;                        animatedScale.animateTo(pressScale, pressAnimationSpec)&#10;                    }&#10;                    pressJob = coroutineScope.launch {&#10;                        delay(500)&#10;                        if (isPressed) {&#10;                            hasTriggeredLongPress = true&#10;                            haptics?.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                            onPress()&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Release -&gt; {&#10;                    if (isPressed) {&#10;                        isPressed = false&#10;                        pressJob?.cancel()&#10;                        pressJob = null&#10;&#10;                        coroutineScope.launch {&#10;                            val targetScale = if (isHovered) hoverScale else 1f&#10;                            animatedScale.animateTo(targetScale, releaseAnimationSpec)&#10;                        }&#10;                        if (!hasTriggeredLongPress) {&#10;                            onClick()&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Enter -&gt; {&#10;                    isHovered = true&#10;                    if (!isPressed) {&#10;                        coroutineScope.launch {&#10;                            animatedScale.animateTo(hoverScale, hoverAnimationSpec)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Exit -&gt; {&#10;                    isHovered = false&#10;                    if (!isPressed) {&#10;                        coroutineScope.launch {&#10;                            launch { animatedScale.animateTo(1f, hoverAnimationSpec) }&#10;                            launch { animatedOffsetX.animateTo(0f, hoverAnimationSpec) }&#10;                            launch { animatedOffsetY.animateTo(0f, hoverAnimationSpec) }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                PointerEventType.Move -&gt; {&#10;                    if (isHovered &amp;&amp; !isPressed) {&#10;                        val position = pointerEvent.changes.firstOrNull()?.position&#10;                        position?.let { pos -&gt;&#10;                            val centerX = bounds.width / 2f&#10;                            val centerY = bounds.height / 2f&#10;&#10;                            // Calculate offset relative to center&#10;                            val offsetX = (pos.x - centerX) / centerX&#10;                            val offsetY = (pos.y - centerY) / centerY&#10;&#10;                            // Limit offset range and apply maximum offset&#10;                            val clampedOffsetX = offsetX.coerceIn(-1f, 1f) * maxHoverOffset&#10;                            val clampedOffsetY = offsetY.coerceIn(-1f, 1f) * maxHoverOffset&#10;&#10;                            // Set values directly without animation for immediate following effect&#10;                            coroutineScope.launch {&#10;                                animatedOffsetX.snapTo(clampedOffsetX)&#10;                                animatedOffsetY.snapTo(clampedOffsetY)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCancelPointerInput() {&#10;        isPressed = false&#10;        coroutineScope.launch {&#10;            val targetScale = if (isHovered) hoverScale else 1f&#10;            launch { animatedScale.animateTo(targetScale, releaseAnimationSpec) }&#10;            launch { animatedOffsetX.animateTo(0f, releaseAnimationSpec) }&#10;            launch { animatedOffsetY.animateTo(0f, releaseAnimationSpec) }&#10;        }&#10;    }&#10;&#10;    override fun MeasureScope.measure(&#10;        measurable: Measurable,&#10;        constraints: Constraints&#10;    ): MeasureResult {&#10;        val placeable = measurable.measure(constraints)&#10;        haptics = currentValueOf(LocalHapticFeedback)&#10;        return layout(placeable.width, placeable.height) {&#10;            placeable.placeWithLayer(0, 0, layerBlock = layerBlock)&#10;        }&#10;    }&#10;}&#10;&#10;private data class ClickFeedbackElement(&#10;    val pressScale: Float,&#10;    val hoverScale: Float,&#10;    val pressAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val releaseAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val hoverAnimationSpec: AnimationSpec&lt;Float&gt;,&#10;    val maxHoverOffset: Float = 8f,&#10;    val onPress: () -&gt; Unit,&#10;    val onClick: () -&gt; Unit&#10;) : ModifierNodeElement&lt;ClickFeedbackNode&gt;() {&#10;    override fun InspectorInfo.inspectableProperties() {&#10;        name = &quot;ClickFeedback&quot;&#10;        properties[&quot;pressScale&quot;] = pressScale&#10;        properties[&quot;hoverScale&quot;] = hoverScale&#10;        properties[&quot;pressAnimationSpec&quot;] = pressAnimationSpec&#10;        properties[&quot;releaseAnimationSpec&quot;] = releaseAnimationSpec&#10;        properties[&quot;hoverAnimationSpec&quot;] = hoverAnimationSpec&#10;        properties[&quot;maxHoverOffset&quot;] = maxHoverOffset&#10;        properties[&quot;onPress&quot;] = onPress&#10;        properties[&quot;onClick&quot;] = onClick&#10;    }&#10;&#10;&#10;    override fun create(): ClickFeedbackNode {&#10;        return ClickFeedbackNode(&#10;            pressScale, hoverScale, pressAnimationSpec, releaseAnimationSpec,&#10;            hoverAnimationSpec, maxHoverOffset,&#10;            onPress, onClick&#10;        )&#10;    }&#10;&#10;    override fun update(node: ClickFeedbackNode) {&#10;        node.pressScale = pressScale&#10;        node.hoverScale = hoverScale&#10;        node.pressAnimationSpec = pressAnimationSpec&#10;        node.releaseAnimationSpec = releaseAnimationSpec&#10;        node.hoverAnimationSpec = hoverAnimationSpec&#10;        node.maxHoverOffset = maxHoverOffset&#10;        node.onPress = onPress&#10;        node.onClick = onClick&#10;    }&#10;}&#10;&#10;fun Modifier.clickFeedback(&#10;    pressScale: Float = 0.95f,&#10;    hoverScale: Float = 1.05f,&#10;    pressAnimationSpec: AnimationSpec&lt;Float&gt; = tween(100),&#10;    releaseAnimationSpec: AnimationSpec&lt;Float&gt; = tween(400),&#10;    hoverAnimationSpec: AnimationSpec&lt;Float&gt; = tween(400),&#10;    maxHoverOffset: Float = 8f,&#10;    onPress: () -&gt; Unit = {},&#10;    onClick: () -&gt; Unit&#10;): Modifier = this then ClickFeedbackElement(&#10;    pressScale, hoverScale, pressAnimationSpec, releaseAnimationSpec,&#10;    hoverAnimationSpec, maxHoverOffset,&#10;    onPress, onClick&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/src/main/kotlin/com/mocharealm/accompanist/lyrics/ui/composable/SpringLazyColumn.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/src/main/kotlin/com/mocharealm/accompanist/lyrics/ui/composable/SpringLazyColumn.kt" />
              <option name="originalContent" value="package com.mocharealm.accompanist.lyrics.ui.composable&#10;&#10;import androidx.compose.animation.core.AnimationSpec&#10;import androidx.compose.animation.core.animate&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.OverscrollEffect&#10;import androidx.compose.foundation.gestures.FlingBehavior&#10;import androidx.compose.foundation.gestures.ScrollableDefaults&#10;import androidx.compose.foundation.gestures.animateScrollBy&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyItemScope&#10;import androidx.compose.foundation.lazy.LazyListScope&#10;import androidx.compose.foundation.lazy.LazyListState&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.rememberOverscrollEffect&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.Stable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableFloatStateOf&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.withFrameNanos&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.abs&#10;import kotlin.math.pow&#10;&#10;// 类型别名和内部状态类&#10;private typealias PhysicsParams = Triple&lt;Float, Float, Float&gt; // stiffness, damping, drag&#10;&#10;class SpringItemState {&#10;    var position by mutableFloatStateOf(0f)&#10;    var velocity by mutableFloatStateOf(0f)&#10;}&#10;&#10;/**&#10; * SpringLazyColumn 的状态持有者。&#10; * 它包含了底层的 LazyListState，并暴露了与物理动画交互的API。&#10; *&#10; * @param lazyListState 内部持有的标准 LazyListState。&#10; * @param coroutineScope 用于启动动画协程的范围。&#10; */&#10;@Stable&#10;class SpringLazyListState(&#10;    val lazyListState: LazyListState,&#10;    private val coroutineScope: CoroutineScope&#10;) {&#10;    internal val itemStates = mutableStateListOf&lt;SpringItemState&gt;()&#10;&#10;    val isScrollInProgress: Boolean&#10;        get() = lazyListState.isScrollInProgress&#10;&#10;    /**&#10;     * &quot;拨动&quot;列表中的某一项。此方法会【并发】启动滚动动画和物理冲击动画。&#10;     *&#10;     * @param itemIndex 要拨动的项在核心列表中的索引。&#10;     * @param targetVelocity 最终要达到的目标速度增量。&#10;     * @param scrollAnimationSpec (可选) 定义滚动动画的曲线。如果为null或目标项不可见，则使用默认滚动。&#10;     * @param accelerationSpec (可选) 定义速度如何从0加速到目标值的动画曲线。&#10;     * @param offset (可选) 滚动完成后，目标项距离视口顶部的最终像素偏移量。&#10;     * @param propagationDepth (可选) 速度传播的深度。&#10;     * @param propagationFalloff (可选) 速度传播的衰减率。&#10;     */&#10;    fun pluck(&#10;        itemIndex: Int,&#10;        targetVelocity: Float,&#10;        scrollAnimationSpec: AnimationSpec&lt;Float&gt;? = null,&#10;        accelerationSpec: AnimationSpec&lt;Float&gt; = tween(300),&#10;        offset: Int = 0,&#10;        propagationDepth: Int = 3,&#10;        propagationFalloff: Float = 0.4f&#10;    ) {&#10;        coroutineScope.launch {&#10;            val targetItemInfo =&#10;                lazyListState.layoutInfo.visibleItemsInfo.find { it.index == itemIndex }&#10;&#10;            if (scrollAnimationSpec != null &amp;&amp; targetItemInfo != null) {&#10;                lazyListState.animateScrollBy(&#10;                    value = (targetItemInfo.offset + offset+900).toFloat(),&#10;                    animationSpec = scrollAnimationSpec&#10;                )&#10;            } else {&#10;                lazyListState.animateScrollToItem(itemIndex, offset+300)&#10;            }&#10;        }&#10;&#10;        coroutineScope.launch {&#10;            if (itemIndex in itemStates.indices) {&#10;                for (i in 0 until propagationDepth) {&#10;                    val currentIndex = itemIndex + i&#10;                    if (currentIndex in itemStates.indices) {&#10;                        val velocityToReach = targetVelocity * (propagationFalloff.pow(i))&#10;&#10;                        launch {&#10;                            val itemState = itemStates[currentIndex]&#10;                            val startVelocity = itemState.velocity&#10;                            val finalVelocity = startVelocity + velocityToReach&#10;&#10;                            animate(&#10;                                initialValue = startVelocity,&#10;                                targetValue = finalVelocity,&#10;                                animationSpec = accelerationSpec&#10;                            ) { value, _ -&gt;&#10;                                itemState.velocity = value&#10;                            }&#10;                        }&#10;                    } else {&#10;                        break&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    internal fun syncItemCount(count: Int) {&#10;        val currentSize = itemStates.size&#10;        if (count &gt; currentSize) {&#10;            val diff = count - currentSize&#10;            itemStates.addAll(List(diff) { SpringItemState() })&#10;        } else if (count &lt; currentSize) {&#10;            itemStates.removeRange(count, currentSize)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 创建并记住一个 SpringLazyListState。&#10; * @return 一个新的 SpringLazyListState 实例。&#10; */&#10;@Composable&#10;fun rememberSpringLazyListState(): SpringLazyListState {&#10;    val lazyListState = rememberLazyListState()&#10;    val scope = rememberCoroutineScope()&#10;    return remember {&#10;        SpringLazyListState(lazyListState, scope)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun &lt;T&gt; SpringLazyColumn(&#10;    items: List&lt;T&gt;,&#10;    itemContent: @Composable LazyItemScope.(index: Int, item: T) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    state: SpringLazyListState = rememberSpringLazyListState(),&#10;    key: ((item: T) -&gt; Any)? = null,&#10;    prefixContent: (LazyListScope.() -&gt; Unit)? = null,&#10;    suffixContent: (LazyListScope.() -&gt; Unit)? = null,&#10;    livelyParams: PhysicsParams = Triple(500f, 4f, 2f),&#10;    crispParams: PhysicsParams = Triple(500f, 45f, 25f),&#10;    velocityThreshold: Float = 80f,&#10;    contentPadding: PaddingValues = PaddingValues(0.dp),&#10;    reverseLayout: Boolean = false,&#10;    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,&#10;    horizontalAlignment: Alignment.Horizontal = Alignment.Start,&#10;    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),&#10;    userScrollEnabled: Boolean = true,&#10;    overscrollEffect: OverscrollEffect? = rememberOverscrollEffect()&#10;) {&#10;    LaunchedEffect(items.size) {&#10;        state.syncItemCount(items.size)&#10;    }&#10;&#10;    fun getParamsForVelocity(velocity: Float): PhysicsParams {&#10;        return if (abs(velocity) &gt; velocityThreshold) livelyParams else crispParams&#10;    }&#10;&#10;    LaunchedEffect(state.itemStates, livelyParams, crispParams, velocityThreshold) {&#10;        var lastFrameTimeNanos = -1L&#10;        val forces = FloatArray(state.itemStates.size)&#10;&#10;        while (true) {&#10;            withFrameNanos { frameTimeNanos -&gt;&#10;                if (lastFrameTimeNanos &gt; 0) {&#10;                    val deltaTime = (frameTimeNanos - lastFrameTimeNanos) / 1_000_000_000f&#10;&#10;                    if (forces.size != state.itemStates.size) {&#10;                        lastFrameTimeNanos = frameTimeNanos&#10;                    }&#10;&#10;                    for (i in state.itemStates.indices) {&#10;                        val itemState = state.itemStates[i]&#10;                        var totalForce = 0f&#10;                        val (stiffness, damping, drag) = getParamsForVelocity(itemState.velocity)&#10;                        if (i &gt; 0) {&#10;                            val neighborState = state.itemStates[i - 1]&#10;                            val (neighborStiffness, _, _) = getParamsForVelocity(neighborState.velocity)&#10;                            val effectiveStiffness = (stiffness + neighborStiffness) / 2f&#10;                            totalForce += effectiveStiffness * (neighborState.position - itemState.position)&#10;                        }&#10;                        if (i &lt; state.itemStates.size - 1) {&#10;                            val neighborState = state.itemStates[i + 1]&#10;                            val (neighborStiffness, _, _) = getParamsForVelocity(neighborState.velocity)&#10;                            val effectiveStiffness = (stiffness + neighborStiffness) / 2f&#10;                            totalForce += effectiveStiffness * (neighborState.position - itemState.position)&#10;                        }&#10;                        totalForce += -drag * itemState.position&#10;                        totalForce += -damping * itemState.velocity&#10;                        forces[i] = totalForce&#10;                    }&#10;&#10;                    // --- 阶段二: 应用所有力来更新状态 ---&#10;                    for (i in state.itemStates.indices) {&#10;                        val itemState = state.itemStates[i]&#10;                        val acceleration = forces[i]&#10;                        itemState.velocity += acceleration * deltaTime&#10;                        itemState.position += itemState.velocity * deltaTime&#10;                    }&#10;                }&#10;                lastFrameTimeNanos = frameTimeNanos&#10;            }&#10;        }&#10;    }&#10;&#10;    LazyColumn(&#10;        modifier = modifier,&#10;        state = state.lazyListState,&#10;        contentPadding = contentPadding,&#10;        reverseLayout = reverseLayout,&#10;        verticalArrangement = verticalArrangement,&#10;        horizontalAlignment = horizontalAlignment,&#10;        flingBehavior = flingBehavior,&#10;        userScrollEnabled = userScrollEnabled,&#10;        overscrollEffect = overscrollEffect&#10;    ) {&#10;        prefixContent?.invoke(this)&#10;        itemsIndexed(&#10;            items = items,&#10;            key = if (key != null) { _, item -&gt; key(item) } else null) { index, item -&gt;&#10;            val springState = state.itemStates.getOrNull(index)&#10;&#10;            if (springState != null) {&#10;                Box(&#10;                    modifier = Modifier.graphicsLayer {&#10;                        translationY = springState.position&#10;                    }) {&#10;                    this@itemsIndexed.itemContent(index, item)&#10;                }&#10;            } else {&#10;                this@itemsIndexed.itemContent(index, item)&#10;            }&#10;        }&#10;        suffixContent?.invoke(this)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mocharealm.accompanist.lyrics.ui.composable&#10;&#10;import androidx.compose.animation.core.AnimationSpec&#10;import androidx.compose.animation.core.animate&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.OverscrollEffect&#10;import androidx.compose.foundation.gestures.FlingBehavior&#10;import androidx.compose.foundation.gestures.ScrollableDefaults&#10;import androidx.compose.foundation.gestures.animateScrollBy&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyItemScope&#10;import androidx.compose.foundation.lazy.LazyListScope&#10;import androidx.compose.foundation.lazy.LazyListState&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.rememberOverscrollEffect&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.Stable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableFloatStateOf&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.withFrameNanos&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.abs&#10;import kotlin.math.pow&#10;&#10;// Type aliases and internal state classes&#10;private typealias PhysicsParams = Triple&lt;Float, Float, Float&gt; // stiffness, damping, drag&#10;&#10;class SpringItemState {&#10;    var position by mutableFloatStateOf(0f)&#10;    var velocity by mutableFloatStateOf(0f)&#10;}&#10;&#10;/**&#10; * SpringLazyColumn 的状态持有者。&#10; * 它包含了底层的 LazyListState，并暴露了与物理动画交互的API。&#10; *&#10; * @param lazyListState 内部持有的标准 LazyListState。&#10; * @param coroutineScope 用于启动动画协程的范围。&#10; */&#10;@Stable&#10;class SpringLazyListState(&#10;    val lazyListState: LazyListState,&#10;    private val coroutineScope: CoroutineScope&#10;) {&#10;    internal val itemStates = mutableStateListOf&lt;SpringItemState&gt;()&#10;&#10;    val isScrollInProgress: Boolean&#10;        get() = lazyListState.isScrollInProgress&#10;&#10;    /**&#10;     * &quot;拨动&quot;列表中的某一项。此方法会【并发】启动滚动动画和物理冲击动画。&#10;     *&#10;     * @param itemIndex 要拨动的项在核心列表中的索引。&#10;     * @param targetVelocity 最终要达到的目标速度增量。&#10;     * @param scrollAnimationSpec (可选) 定义滚动动画的曲线。如果为null或目标项不可见，则使用默认滚动。&#10;     * @param accelerationSpec (可选) 定义速度如何从0加速到目标值的动画曲线。&#10;     * @param offset (可选) 滚动完成后，目标项距离视口顶部的最终像素偏移量。&#10;     * @param propagationDepth (可选) 速度传播的深度。&#10;     * @param propagationFalloff (可选) 速度传播的衰减率。&#10;     */&#10;    fun pluck(&#10;        itemIndex: Int,&#10;        targetVelocity: Float,&#10;        scrollAnimationSpec: AnimationSpec&lt;Float&gt;? = null,&#10;        accelerationSpec: AnimationSpec&lt;Float&gt; = tween(300),&#10;        offset: Int = 0,&#10;        propagationDepth: Int = 3,&#10;        propagationFalloff: Float = 0.4f&#10;    ) {&#10;        coroutineScope.launch {&#10;            val targetItemInfo =&#10;                lazyListState.layoutInfo.visibleItemsInfo.find { it.index == itemIndex }&#10;&#10;            if (scrollAnimationSpec != null &amp;&amp; targetItemInfo != null) {&#10;                lazyListState.animateScrollBy(&#10;                    value = (targetItemInfo.offset + offset+900).toFloat(),&#10;                    animationSpec = scrollAnimationSpec&#10;                )&#10;            } else {&#10;                lazyListState.animateScrollToItem(itemIndex, offset+300)&#10;            }&#10;        }&#10;&#10;        coroutineScope.launch {&#10;            if (itemIndex in itemStates.indices) {&#10;                for (i in 0 until propagationDepth) {&#10;                    val currentIndex = itemIndex + i&#10;                    if (currentIndex in itemStates.indices) {&#10;                        val velocityToReach = targetVelocity * (propagationFalloff.pow(i))&#10;&#10;                        launch {&#10;                            val itemState = itemStates[currentIndex]&#10;                            val startVelocity = itemState.velocity&#10;                            val finalVelocity = startVelocity + velocityToReach&#10;&#10;                            animate(&#10;                                initialValue = startVelocity,&#10;                                targetValue = finalVelocity,&#10;                                animationSpec = accelerationSpec&#10;                            ) { value, _ -&gt;&#10;                                itemState.velocity = value&#10;                            }&#10;                        }&#10;                    } else {&#10;                        break&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    internal fun syncItemCount(count: Int) {&#10;        val currentSize = itemStates.size&#10;        if (count &gt; currentSize) {&#10;            val diff = count - currentSize&#10;            itemStates.addAll(List(diff) { SpringItemState() })&#10;        } else if (count &lt; currentSize) {&#10;            itemStates.removeRange(count, currentSize)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 创建并记住一个 SpringLazyListState。&#10; * @return 一个新的 SpringLazyListState 实例。&#10; */&#10;@Composable&#10;fun rememberSpringLazyListState(): SpringLazyListState {&#10;    val lazyListState = rememberLazyListState()&#10;    val scope = rememberCoroutineScope()&#10;    return remember {&#10;        SpringLazyListState(lazyListState, scope)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun &lt;T&gt; SpringLazyColumn(&#10;    items: List&lt;T&gt;,&#10;    itemContent: @Composable LazyItemScope.(index: Int, item: T) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    state: SpringLazyListState = rememberSpringLazyListState(),&#10;    key: ((item: T) -&gt; Any)? = null,&#10;    prefixContent: (LazyListScope.() -&gt; Unit)? = null,&#10;    suffixContent: (LazyListScope.() -&gt; Unit)? = null,&#10;    livelyParams: PhysicsParams = Triple(500f, 4f, 2f),&#10;    crispParams: PhysicsParams = Triple(500f, 45f, 25f),&#10;    velocityThreshold: Float = 80f,&#10;    contentPadding: PaddingValues = PaddingValues(0.dp),&#10;    reverseLayout: Boolean = false,&#10;    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,&#10;    horizontalAlignment: Alignment.Horizontal = Alignment.Start,&#10;    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),&#10;    userScrollEnabled: Boolean = true,&#10;    overscrollEffect: OverscrollEffect? = rememberOverscrollEffect()&#10;) {&#10;    LaunchedEffect(items.size) {&#10;        state.syncItemCount(items.size)&#10;    }&#10;&#10;    fun getParamsForVelocity(velocity: Float): PhysicsParams {&#10;        return if (abs(velocity) &gt; velocityThreshold) livelyParams else crispParams&#10;    }&#10;&#10;    LaunchedEffect(state.itemStates, livelyParams, crispParams, velocityThreshold) {&#10;        var lastFrameTimeNanos = -1L&#10;        val forces = FloatArray(state.itemStates.size)&#10;&#10;        while (true) {&#10;            withFrameNanos { frameTimeNanos -&gt;&#10;                if (lastFrameTimeNanos &gt; 0) {&#10;                    val deltaTime = (frameTimeNanos - lastFrameTimeNanos) / 1_000_000_000f&#10;&#10;                    if (forces.size != state.itemStates.size) {&#10;                        lastFrameTimeNanos = frameTimeNanos&#10;                    }&#10;&#10;                    for (i in state.itemStates.indices) {&#10;                        val itemState = state.itemStates[i]&#10;                        var totalForce = 0f&#10;                        val (stiffness, damping, drag) = getParamsForVelocity(itemState.velocity)&#10;                        if (i &gt; 0) {&#10;                            val neighborState = state.itemStates[i - 1]&#10;                            val (neighborStiffness, _, _) = getParamsForVelocity(neighborState.velocity)&#10;                            val effectiveStiffness = (stiffness + neighborStiffness) / 2f&#10;                            totalForce += effectiveStiffness * (neighborState.position - itemState.position)&#10;                        }&#10;                        if (i &lt; state.itemStates.size - 1) {&#10;                            val neighborState = state.itemStates[i + 1]&#10;                            val (neighborStiffness, _, _) = getParamsForVelocity(neighborState.velocity)&#10;                            val effectiveStiffness = (stiffness + neighborStiffness) / 2f&#10;                            totalForce += effectiveStiffness * (neighborState.position - itemState.position)&#10;                        }&#10;                        totalForce += -drag * itemState.position&#10;                        totalForce += -damping * itemState.velocity&#10;                        forces[i] = totalForce&#10;                    }&#10;&#10;                    // --- Phase 2: Apply all forces to update state ---&#10;                    for (i in state.itemStates.indices) {&#10;                        val itemState = state.itemStates[i]&#10;                        val acceleration = forces[i]&#10;                        itemState.velocity += acceleration * deltaTime&#10;                        itemState.position += itemState.velocity * deltaTime&#10;                    }&#10;                }&#10;                lastFrameTimeNanos = frameTimeNanos&#10;            }&#10;        }&#10;    }&#10;&#10;    LazyColumn(&#10;        modifier = modifier,&#10;        state = state.lazyListState,&#10;        contentPadding = contentPadding,&#10;        reverseLayout = reverseLayout,&#10;        verticalArrangement = verticalArrangement,&#10;        horizontalAlignment = horizontalAlignment,&#10;        flingBehavior = flingBehavior,&#10;        userScrollEnabled = userScrollEnabled,&#10;        overscrollEffect = overscrollEffect&#10;    ) {&#10;        prefixContent?.invoke(this)&#10;        itemsIndexed(&#10;            items = items,&#10;            key = if (key != null) { _, item -&gt; key(item) } else null) { index, item -&gt;&#10;            val springState = state.itemStates.getOrNull(index)&#10;&#10;            if (springState != null) {&#10;                Box(&#10;                    modifier = Modifier.graphicsLayer {&#10;                        translationY = springState.position&#10;                    }) {&#10;                    this@itemsIndexed.itemContent(index, item)&#10;                }&#10;            } else {&#10;                this@itemsIndexed.itemContent(index, item)&#10;            }&#10;        }&#10;        suffixContent?.invoke(this)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/your_file.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/your_file.kt" />
              <option name="updatedContent" value="// ...existing code...&#10;    val firstSyllableStart = lineLayout.first().syllable.start&#10;    val lastSyllableEnd = lineLayout.last().syllable.end&#10;// ...existing code...&#10;    val fadeInEndTime = firstSyllableStart + fadeInDuration&#10;    val fadeOutStartTime = lastSyllableEnd - fadeOutDuration&#10;&#10;    val lineProgress = run {&#10;        val activeSyllable = lineLayout.find {&#10;            currentTimeMs in it.syllable.start until it.syllable.end&#10;        }&#10;&#10;        val currentPixelPosition = when {&#10;            activeSyllable != null -&gt; {&#10;                // 在当前音节内，根据音节进度计算像素位置&#10;                val syllableProgress = activeSyllable.syllable.progress(currentTimeMs)&#10;                activeSyllable.position.x + activeSyllable.size.width * syllableProgress&#10;            }&#10;&#10;            currentTimeMs &gt;= lastSyllableEnd -&gt; totalWidth // 整行结束&#10;&#10;            currentTimeMs &lt; firstSyllableStart -&gt; 0f // 整行未开始&#10;&#10;            else -&gt; {&#10;                // 在音节之间，实现平滑过渡&#10;                val lastFinishedIndex = lineLayout.indexOfLast { currentTimeMs &gt;= it.syllable.end }&#10;                val lastFinished = lineLayout.getOrNull(lastFinishedIndex)&#10;                val nextSyllable = lineLayout.getOrNull(lastFinishedIndex + 1)&#10;&#10;                if (lastFinished != null &amp;&amp; nextSyllable != null) {&#10;                    val gapStartTime = lastFinished.syllable.end&#10;                    val gapEndTime = nextSyllable.syllable.start&#10;                    val gapDuration = gapEndTime - gapStartTime&#10;&#10;                    val startPixel = lastFinished.position.x + lastFinished.size.width&#10;                    val endPixel = nextSyllable.position.x&#10;&#10;                    if (gapDuration &gt; 0) {&#10;                        val gapProgress = (currentTimeMs - gapStartTime).toFloat() / gapDuration&#10;                        // 在上一个音节末尾和下一个音节开头之间进行线性插值&#10;                        startPixel + (endPixel - startPixel) * gapProgress&#10;                    } else {&#10;                        // 如果没有间隙，直接跳到下一个音节的开始位置&#10;                        endPixel&#10;                    }&#10;                } else {&#10;                    // 理论上不应发生，作为备用&#10;                    val lastFinishedSyllable = lineLayout.lastOrNull { currentTimeMs &gt;= it.syllable.end }&#10;                    lastFinishedSyllable?.let { it.position.x + it.size.width } ?: 0f&#10;                }&#10;            }&#10;        }&#10;        (currentPixelPosition / totalWidth).coerceIn(0f, 1f)&#10;    }&#10;&#10;    val fadeRange = run {&#10;// ...existing code...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>